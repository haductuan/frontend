import LocalStorageDB from "../db/localStorageDb";
import * as bip39 from "bip39";
import { generate_randombytes_buf, sodium } from "./cryptographyUtils";
import { Entry } from "@zidendev/zidenjs/build/claim/entry";
import {
  encrypt_and_prepend_nonce,
  decrypt_after_extracting_nonce,
} from "./cryptographyUtils";

//zidenjs
import { trees, claim, utils as zidenjsUtils, db } from "@zidendev/zidenjs";
const { SMTLevelDb } = db;
const { Trees, SMTType } = trees;
const { IDType } = claim.id;
//generate key
const hdkey = require("hdkey");
const pbkdf2 = require("pbkdf2");

const claimsDb = new SMTLevelDb("ziden/claims-tree-db");
const revocationDb = new SMTLevelDb("ziden/revocation-tree-db");
const rootsDb = new SMTLevelDb("ziden/roots-tree-db");

const WALLET_LOCKED_MESSAGE = "Wallet not unlocked";

export default class KeyContainer {
  name: string;
  encryptionKey: Uint8Array;
  db: any;
  timer: any;
  constructor(db: any) {
    this.name = "ziden";
    this.encryptionKey = new Uint8Array();
    if (db) {
      this.db = db;
    } else {
      this.db = new LocalStorageDB(this.name);
    }
    this.timer = {};
  }

  unlock(password: string) {
    const passwordHash = pbkdf2.pbkdf2Sync(password, "salt", 256, 32, "sha512"); // password hash in buffer
    this.encryptionKey = passwordHash;
    clearTimeout(this.timer);
    const self = this;
    this.timer = setTimeout(() => {
      console.log("key expired");
      self.encryptionKey = new Uint8Array();
    }, 28800000);
  }
  getEncryptionKey(password: string) {
    const passwordHash = pbkdf2.pbkdf2Sync(password, "salt", 256, 32, "sha512"); // password hash in buffer
    return passwordHash;
  }
  isUnlock() {
    if (this.encryptionKey.length !== 0) {
      return true;
    }
    return false;
  }
  lock() {
    if (!this.encryptionKey) {
      return;
    }
    clearTimeout(this.timer);
    // key container locked
    this.encryptionKey = new Uint8Array();
  }
  encrypt(message: string) {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    return encrypt_and_prepend_nonce(this.encryptionKey, message);
  }
  encryptWithDataKey(message: string) {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    const dataKey = this.db.get("ziden-data-key");
    if (!dataKey) {
      console.log("Data key not exist");
      return;
    }
    const dataKeyDecrypted = this.decrypt(dataKey);
    return encrypt_and_prepend_nonce(
      Buffer.from(dataKeyDecrypted, "hex"),
      message
    );
  }
  encryptAndStore(message: string, key: string) {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    try {
      this.db.insert(key, this.encrypt(message));
      return true;
    } catch (err) {
      return false;
    }
  }
  encryptAndStoreWithDataKey(message: string, key: string) {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    try {
      this.db.insert(key, this.encryptWithDataKey(message));
      return true;
    } catch (err) {
      console.log(err);
      return false;
    }
  }
  /**
   * Decrypt data get from localStorate with provided key using encryption key
   * @param key
   * @returns
   */
  decryptFromDB(key: string) {
    if (!this.isUnlock()) {
      return "";
    }
    const encrypted = this.db.get(key);
    if (!encrypted) {
      console.log("field empty");
      return "";
    }
    try {
      return this.decrypt(encrypted);
    } catch (err) {
      console.log(err);
      return "";
    }
  }
  decrypt(EncryptedMessage: string) {
    if (!this.isUnlock()) {
      return "";
    }
    //return decrypt(this.encryptionKey, EncryptedMessage);
    return decrypt_after_extracting_nonce(this.encryptionKey, EncryptedMessage);
  }
  decryptWithDataKey(EncryptedMessage: string) {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    const dataKey = this.db.get("ziden-data-key");
    if (!dataKey) {
      throw Error("Data key doesn't exist");
    }
    const dataKeyDecrypted = this.decrypt(dataKey);
    return decrypt_after_extracting_nonce(
      Buffer.from(dataKeyDecrypted, "hex"),
      EncryptedMessage
    );
  }
  decryptWithKey(key: Uint8Array, message: string) {
    //return decrypt(key, message);
    return decrypt_after_extracting_nonce(key, message);
  }
  generateMasterSeed() {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    const mnemonic = bip39.generateMnemonic();
    return mnemonic;
  }
  setMasterSeed(InputMnemonic: string) {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    let mnemonic;
    if (InputMnemonic) {
      if (bip39.validateMnemonic(InputMnemonic)) {
        mnemonic = InputMnemonic;
        this.db.insert("ziden-user-masterseed", this.encrypt(mnemonic));
      } else {
        throw Error("Invalid mnemonic");
      }
    } else {
      mnemonic = bip39.generateMnemonic();
      this.db.insert("ziden-user-masterseed", this.encrypt(mnemonic));
    }
  }
  getMasterSeedDecrypted() {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    const masterSeedEncrypted = this.db.get("ziden-user-masterseed");
    if (masterSeedEncrypted === undefined) {
      throw Error("Mnemonic desn't exist");
    } else {
      return this.decrypt(masterSeedEncrypted);
    }
  }
  getMasterSeed() {
    const masterSeedEncrypted = this.db.get("ziden-user-masterseed");
    if (masterSeedEncrypted === undefined) {
      throw Error("Master seed not exist!");
    } else {
      return masterSeedEncrypted;
    }
  }
  generateKeyFromSeed(masterSeed: string) {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    const masterSeedBuffer = Buffer.from(masterSeed, "utf-8");
    const keyRoot = hdkey.fromMasterSeed(masterSeedBuffer);
    const keyPathRoot = "m/44'/0'/0";
    const Id = keyRoot.derive(keyPathRoot);
    const publicKey = Id._publicKey.toString("hex");
    this.db.insert("ziden-publicKeyEncrypted", this.encrypt(publicKey));
    const privateKey = Id._privateKey.toString("hex");
    this.db.insert("ziden-privateKeyEncrypted", this.encrypt(privateKey));
    return { publicKey: publicKey, privateKey: privateKey };
  }
  //generate private key and auth claim from master seed
  generateZidenKeyFromMasterSeed = async (masterSeed: string) => {
    // ziden
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    const masterSeedBuffer = Buffer.from(masterSeed, "utf-8");
    const keyRoot = hdkey.fromMasterSeed(masterSeedBuffer);
    const keyPathRoot = "m/44'/0'/0";
    const Id = keyRoot.derive(keyPathRoot);
    const privateKeyBuff = Id._privateKey;
    const privateKeyHex = zidenjsUtils.bufferToHex(privateKeyBuff);
    this.db.insert("ziden-privateKeyEncrypted", this.encrypt(privateKeyHex));
    const authClaim = await claim.authClaim.newAuthClaimFromPrivateKey(
      privateKeyBuff
    );
    const authClaimHex = zidenjsUtils.bufferArrayToHex(authClaim.elements);
    this.db.insert("auth-claim", this.encrypt(authClaimHex));
    const idWithBSMT = await Trees.generateID(
      [authClaim],
      claimsDb,
      revocationDb,
      rootsDb,
      IDType.Default,
      32,
      SMTType.BinSMT
    );
    this.db.insert("rootsVersion", idWithBSMT.rootsVersion);
    this.db.insert("revocationNonce", idWithBSMT.revocationNonce);
    this.db.insert(
      "userID",
      this.encrypt(zidenjsUtils.bufferToHex(idWithBSMT.userID))
    );
    const encryptionData = generate_randombytes_buf(32);
    const encryptionDataHex = Buffer.from(encryptionData).toString("hex");
    this.encryptAndStore(encryptionDataHex, "ziden-data-key");
  };
  generateZidenKeyFromPrivateKey = async (privateKey: string) => {
    const privateKeyBuff = zidenjsUtils.hexToBuffer(privateKey, 32);
    this.db.insert("ziden-privateKeyEncrypted", this.encrypt(privateKey));
    const authClaim = await claim.authClaim.newAuthClaimFromPrivateKey(
      privateKeyBuff
    );
    const authClaimHex = zidenjsUtils.bufferArrayToHex(authClaim.elements);
    this.db.insert("auth-claim", this.encrypt(authClaimHex));
    const idWithBSMT = await Trees.generateID(
      [authClaim],
      claimsDb,
      revocationDb,
      rootsDb,
      IDType.Default,
      32,
      SMTType.BinSMT
    );
    this.db.insert("rootsVersion", idWithBSMT.rootsVersion);
    this.db.insert("revocationNonce", idWithBSMT.revocationNonce);
    this.db.insert(
      "userID",
      this.encrypt(zidenjsUtils.bufferToHex(idWithBSMT.userID))
    );
    const encryptionData = generate_randombytes_buf(32);
    const encryptionDataHex = Buffer.from(encryptionData).toString("hex");
    this.encryptAndStore(encryptionDataHex, "ziden-data-key");
  };
  //generate auth claim from public key (for orai wallet user)
  generateZidenKeyFromPublicKey = async (publicKey: Array<any>) => {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    const authClaim = await claim.authClaim.newAuthClaimFromPublicKey(
      publicKey[0],
      publicKey[1]
    );
    const authClaimHex = zidenjsUtils.bufferArrayToHex(authClaim.elements);
    this.db.insert("auth-claim", this.encrypt(authClaimHex));
    const idWithBSMT = await Trees.generateID(
      [authClaim],
      claimsDb,
      revocationDb,
      rootsDb,
      IDType.Default,
      32,
      SMTType.BinSMT
    );

    this.db.insert("rootsVersion", idWithBSMT.rootsVersion);
    this.db.insert("revocationNonce", idWithBSMT.revocationNonce);
    this.db.insert(
      "userID",
      this.encrypt(zidenjsUtils.bufferToHex(idWithBSMT.userID))
    );
    const encryptionData = generate_randombytes_buf(32);
    const encryptionDataHex = Buffer.from(encryptionData).toString("hex");
    this.encryptAndStore(encryptionDataHex, "ziden-data-key");
  };
  //generate key pair for encrypt - decrypt claim from server
  generateKeyForClaim = () => {
    if (sodium) {
      const { publicKey, privateKey } = sodium.crypto_box_keypair();
      return {
        publicKey,
        privateKey,
      };
    } else {
      return null;
    }
  };
  generateHexKeyForClaim = () => {
    if (sodium) {
      const { publicKey, privateKey } = sodium.crypto_box_keypair("hex");
      return {
        publicKey,
        privateKey,
      };
    } else {
      return null;
    }
  };
  getCryptoUtil = () => {
    if (sodium) {
      return sodium;
    } else {
      return null;
    }
  };
  getUserIDFromMasterSeed = async (privateKeyBuff: Buffer, ziden: any) => {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    const authClaim = await claim.authClaim.newAuthClaimFromPrivateKey(
      privateKeyBuff
    );
    const authClaimHex = zidenjsUtils.bufferArrayToHex(authClaim.elements);
    this.db.insert("auth-claim", this.encrypt(authClaimHex));
    const idWithBSMT = await Trees.generateID(
      [authClaim],
      claimsDb,
      revocationDb,
      rootsDb,
      IDType.Default,
      32,
      SMTType.BinSMT
    );
    this.db.insert("rootsVersion", idWithBSMT.rootsVersion);
    this.db.insert("revocationNonce", idWithBSMT.revocationNonce);
    this.db.insert("userID", zidenjsUtils.bufferToHex(idWithBSMT.userID));
    return zidenjsUtils.bufferToHex(idWithBSMT.userID);
  };
  getUserID = () => {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    const userIDDecrypted = this.db.get("userID");
    return this.decrypt(userIDDecrypted);
  };
  getAuthClaims() {
    if (this.isUnlock()) {
      const authClaimHex = this.decrypt(this.db.get("auth-claim"));
      const authBuffer = zidenjsUtils.hexToBufferArray(authClaimHex, 32);
      const authClaims = new Entry(authBuffer);
      return authClaims;
    } else {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
  }
  getUserTree = async (ziden: any) => {
    try {
      await claimsDb.nodes.open();
      await revocationDb.nodes.open();
      await rootsDb.nodes.open();
      const claimsTree = new trees.smt.BinSMT(
        claimsDb,
        await claimsDb.getRoot(),
        32
      );
      const revocationTree = new trees.smt.BinSMT(
        revocationDb,
        await revocationDb.getRoot(),
        32
      );
      const rootsTree = new trees.smt.BinSMT(
        rootsDb,
        await rootsDb.getRoot(),
        32
      );
      const userTree = new trees.Trees(
        claimsTree,
        revocationTree,
        rootsTree,
        this.db.get("rootsVersion"),
        this.db.get("revocationNonce"),
        zidenjsUtils.hexToBuffer(this.decrypt(this.db.get("userID")), 31),
        32
      );
      return userTree;
    } catch (err: any) {
      throw err;
    }
  };
  getKeys() {
    const privateKeyEncrypted = this.db.get("ziden-privateKeyEncrypted");
    return {
      privateKeyEncrypted,
    };
  }
  getKeyDecrypted() {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    const { privateKeyEncrypted } = this.getKeys();
    return {
      privateKey: this.decrypt(privateKeyEncrypted),
    };
  }
  recoverFromMasterSeed(masterSeed: string) {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    this.setMasterSeed(masterSeed);
    this.generateZidenKeyFromMasterSeed(masterSeed);
  }
  generateDekForBackup() {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    const libsodium = this.getCryptoUtil();
    const dek = libsodium.crypto_secretbox_keygen("hex");
    return dek;
  }
  generateKeyForBackup() {
    if (!this.isUnlock()) {
      throw Error(WALLET_LOCKED_MESSAGE);
    }
    const key = this.getKeyDecrypted();
    if (!key) {
      return;
    }
    const libsodium = this.getCryptoUtil();
    let privHex = key.privateKey;
    while (privHex.length < 64) {
      privHex = "0" + privHex;
    }
    const publicKeyHex = libsodium.crypto_scalarmult_base(
      libsodium.from_hex(privHex),
      "hex"
    );
    return {
      privateKey: privHex,
      publicKey: publicKeyHex,
    };
  }
}
